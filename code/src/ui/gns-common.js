;(function(ns) {

    /**
    * @brief Allows to select one among a collection of peers.
    *
    * Calling switchTo() with a key found in @p arrKeys, results in applying
    * class @p clsActive to the element @p arrEls in the corresponding index.
    * Any previously selected element is automatically applied @p clsInactive.
    * At most one element may be selected at a time.
    *
    * @param[in] arrKeys Strings to identify each element in @arrEls (on a
    *   one-on-one basis).
    * @param[in] arrEls Elements to be applied classes @p clsActive and @p
    *   clsInactive.
    * @param[in] clsActive
    * @param[in] clsInactive
    * @param[in] keyDefault Key of the element to select upon instantiation.
    * Optional.
    */
    ns.OneOfMany =
    function (arrKeys, arrEls, clsActive, clsInactive, keyDefault) {
        this.one        =  null;
        this.many       =  {};
        this.active     =  clsActive;
        this.inactive   =  clsInactive;

        var i,              // Index of @p arrKeys-arrEls pair
            el;             // An element from @p arrEls

        for(i = 0 ; i < arrKeys.length ; ++i) {
            el                      =  arrEls[i];
            el.className            =  clsInactive;
            this.many[arrKeys[i]]   =  el;
        }

        if(keyDefault !== undefined) {
            this.switchTo(keyDefault);
        }
    };
    ns.OneOfMany.prototype = {

        /**
        * @brief Selects the element that is paired with @p key.
        *
        * The current element (if any) is set to this.inactive regardless of
        * whether @p key corresponds to an available key.
        *
        * @param[in] key The key for the element to select. If @c null, none
        *   will be selected.
        */
        switchTo : function(key) {
            if(this.one !== null) {
                this.one.className  =  this.inactive;
                this.one            =  null;
            }

            if(this.many[key]) {
                this.one            =  this.many[key];
                this.one.className  =  this.active;
            }
        }
    };

    /**
    * @brief Facilitates manaing pagination controls.
    *
    * Every instance keeps track of an element that displays the number results
    * and a second element for page anchors (pagination). Upon invoking show(),
    * the `innerHTML' of those elements is updated accordingly.
    *
    * The link (`href') of each page anchor is generated by an external
    * function,@p fnLinker. @p clsCurrent is a class string to apply to the page
    * anchor dubbed as current (or selected), while @p clsOther is applied to
    * every other.
    *
    * @param[in] elTotal Element which innerHTML will be set to the amount of
    *   search results.
    * @param[in] elPages Element which innerHTML will be populated with a number
    *   of anchors.
    * @param[in] clsCurrent The currently displayed anchor page will be applied
    *   this class.
    * @param[in] clsOther All anchors, except for the selected one, will be
    *   applied this class.
    * @param[in] fnLinker A function that accepts a page number/index (starting
    *   at @c 1) and returns an appropriate value for its corresponding anchor's
    *   `href' attribute.
    */
    ns.Paginator =
    function (elTotal, elPages, clsCurrent, clsOther, fnLinker) {
        this.elTotal    =  elTotal;
        this.elPages    =  elPages;
        this.clsCurrent =  clsCurrent;
        this.clsOther   =  clsOther;
        this.linker     =  fnLinker;
    };
    ns.Paginator.prototype = {

        /**
        * @brief Update the pagination display.
        *
        * @param[in] results The amount of total results.
        * @param[in] anchors The amount of page links to generate.
        * @param[in] current The index of the currently displayed page (starts
        *   at @c 1). This page will not have its `href' set, whereas its class
        *   will be set to clsCurrent unlike the other anchors that acquire
        *   clsOther.
        */
        show : function(results, anchors, current) {
            var i,
                limit,
                pages   =  "";

            this.elTotal.innerHTML  =  results;
            this.elPages.innerHTML  =  "";

            i       =  1;
            limit   =  current;

            while(i <= anchors) {
                for(i ; i < limit ; ++i) {
                    pages  +=  "<a class=\"" + this.clsOther  + "\" "
                           +      "href=\""  + this.linker(i) + "\">"
                           +   i + "</a>";
                }

                if(i === current) {
                    /* Set the class of the current anchor but do not provide
                    * a link. */
                    pages  +=  "<a class=\"" + this.clsCurrent + "\">"
                           +   i + "</a>";
                    ++i;
                    limit   =  anchors + 1;
                }
            }

            if(pages === "") {
                pages   =  "<a class=\"" + this.clsCurrent + "\">0</a>";
            }
            this.elPages.innerHTML  =  pages;
        },

        /**
        * @brief Set totals @c 0 and page anchors to a single &ndash;.
        */
        reset : function() {
            this.elTotal.value      =  0;
            this.elPages.innerHTML  =  "&ndash;";
        }
    };

    /**
    * @brief Expand @p child's prototype with @p parent's
    *
    * Prototype members than exist on both @p child and @p parent are ignored,
    * by default, unless @p override evaluates to @c true.
    *
    * @param[in,out] child Contains the prototype to be expanded.
    * @param[in,out] parent Contains the prototype to be copied.
    * @param[in] override Replace common prototype members with those of @p
    *   parent.
    */
    ns.augment = ns.augment ||
    function (child, parent, override) {
        var i;

        for(i in parent.prototype) {
            if(child.prototype[i] !== undefined && !override) continue;
            child.prototype[i] = parent.prototype[i];
        }
    }

    /**
    * @brief Register a callback function for a particular element.
    *
    * Currently, a single callback is supported in fallback mode.
    *
    * @param[in] el The element to be attached a listener.
    * @param[in] event String of the event name (non-inclusive of "on").
    * @param[in] fn The callback function / event handler.
    */
    ns.addEventListener = ns.addEventListener ||
    function (el, event, fn) {
        if(el.addEventListener) {
            el.addEventListener(event, fn);

        /* This should suffice for IE versions prior to 9. */
        } else if(el.attachEvent) {
            el.attachEvent("on" + event, fn);

        } else {
            el["on" + event] = fn;
        }
    };

    /**
    * @brief Return an object that can be used to make HTTP request objects.
    *
    * If instantiation of XMLHttpRequest is not possible, Msxml2.XMLHTTP and
    * Microsoft.XMLHTTP will be attempted in that order. If none of these
    * works, @c null is returned. Also, a message is displayed using Logger.
    *
    * @returns An XML HTTP object or @c null.
    */
    ns.createRequest = ns.createRequest ||
    function () {
        var request = null;

        if(window.XMLHttpRequest) {
          request       =  new XMLHttpRequest();

        } else if(window.ActiveXObject) {
          try {
            request     =  new ActiveXObject("Msxml2.XMLHTTP");

          } catch(e) {
            try {
              request   =  new ActiveXObject("Microsoft.XMLHTTP");

            } catch(e) {
            }
          }
        }

        if(request === null) {
            ns.log("Προέκυψε σοβαρό σφάλμα! Δεν ήταν δυνατή η δημιουργία"
                + " αντικειμένου σύνδεσης (XMLHTTPRequest). Φορτώστε πάλι τη"
                + " σελίδα ή προσπαθήστε με πιο σύγχρονο πρόγραμμα.", "fatal");
        }

        return request;
    };

    /**
    * @brief Check whether @p value is NaN.
    *
    * This deals with the issue of isNaN() returning @c false even for
    * non-number values.
    *
    * @param[in] value The value to check.
    * @returns @c true if @p value is NaN; @p false, otherwise.
    */
    ns.isNaN = ns.isNaN ||
    function (value) {
        if(typeof value !== 'number') return false;
        return isNaN(value);
    };

    /**
    * @brief Check whether @p collection is empty.
    *
    * @param[in] collection The collection to check.
    * @returns @c true if @p collection is empty or @c null; @p false,
    *   otherwise.
    */
    ns.isEmpty = ns.isEmpty ||
    function (collection) {
        var i   =  0,
            val;

        for(val in collection) {
            ++i;
            break;
        }
        return i === 0;
    };

    /**
    * @brief Convert a number into a string of fixed digits.
    *
    * @param[in] num The number to prefix with zeros.
    * @param[in] digits The number of total digits to produce.
    * @returns A string number with that many @p digits.
    */
    ns.fixInt = ns.fixInt ||
    function (num, digits) {
        var value   =  num.toString(10),
            times   =  digits - value.length,
            i;

        for(i = 0 ; i < times ; ++i) {
            value = "0" + value;
        }
        return value;
    };

    /**
    * @brief Replace a word within a string with another.
    *
    * The default behaviour is to replace only the first occurrence of @p
    * substring with @p substitute.
    *
    * @param[in] source The initial string.
    * @param[in] substring The string to search for in @p source or,
    *   alternatively, a RegExp object.
    * @param[in] substitute The string to replace @p substring with.
    *
    * @returns The string resulting from the substitution.
    */
    ns.replaceWord = ns.replaceWord ||
    function (source, substring, substitute, first) {
        /* Append spaces to search the word near boundaries, substitute and,
        * then, trim. */
        return (" " + source + " ").replace(substring, substitute)
                                   .replace(/^\s*|\s$/, "");
    };

    /**
    * @brief A Logger Entry.
    *
    * A Logger Entry creates an actual DOM element to contain a message and also
    * keeps a reference to that, along with a time-stamp of its creation. The
    * message, including the specified time-stamp (or Now, if none was
    * specified), is enclosed within a @c div element which is applied the
    * class @c cls. The time-stamp may be used to determine the age of the
    * entry.
    *
    * @param[in] msg The message of the entry (text or HTML).
    * @param[in] cls The class of the entry (enclosing @c div). Optional.
    * @param[in] stamp Date object. The time to link this entry with. Defaults
    *   to Now. Optional.
    * @param hideTime If supplied and it evaluates to true, the generated
    *   element will not contain the time.
    */
    ns.LoggerEntry =
    function (msg, cls, stamp, hideTime) {
        var time;

        this.elEntry    =  document.createElement("div");

        !stamp && (stamp = new Date());
        this.stamp  =  stamp;

        cls && (this.elEntry.className = cls);
        this.elEntry.innerHTML  =  msg;

        if(!hideTime) {
            time    =        ns.fixInt(stamp.getHours(),    2)
                    +  ":" + ns.fixInt(stamp.getMinutes(),  2)
                    +  ":" + ns.fixInt(stamp.getSeconds(),  2);
            this.elEntry.innerHTML  =  time + " - ";
        }
        this.elEntry.innerHTML     +=  msg;

    };

    /**
    * @brief Manages a simple message board.
    *
    * The messages are added as entries within the specified DOM element and
    * contain, on top of the message passed to log(), the time of its
    * invocation.
    * Each new message entry is appended on top of the others, whereas only a
    * maximum number of entries are preserved, the oldest ones being removed
    * (any pre-existent elements within the board, included).
    *
    * For each entry, a severity level may be specified to apply one of three
    * user-defined classes. An additional class is always applied to each new
    * entry, allowing CSS selectors to mark newly-added entries in a special
    * way. This class is removed on a succeeding call to log(), provided the
    * specified amount of seconds have elapsed.
    *
    * If log() is invoked without prior initialisation of Logger, the message
    * will be displayed with alert().
    */
    ns.Logger = ns.Logger || (function () {

        var elLog,
            entries     =  [],
            children,
            entriesMax,
            expires,
            clsNew,
            clsInfo,
            clsCritical,
            clsFatal;

        var isInit;         // Whether Logger has been initialised. If not, log
                            // will fallback to alert().

        /**
        * @brief Initialise the Logger.
        *
        * @c elLog is parsed and its current children elements are counted as
        * entries (although, they won't be subjected to class removal on
        * successive calls to log()). During this process, all excess children
        * will be removed; at most, the *first* @c entries children are
        * preserved.
        *
        * All settings are required.
        *
        * @param[in] s Object with initialisation settings. It should contain
        *   the following keys, each with a value as follows:@verbatim {
        * elId                  id of the message log element (should accept
        *                       Flow Content)
        * entries               Maximum number of entries to display
        * expires               Each entry will retain clsNew for at least this
        *                       many seconds.
        * clsInfo               Class to apply to all information messages
        * clsCritical           Class to apply to all critical messages
        * clsFatal              Class to apply to all fatal messages
        * clsNew                Additional class to apply to new entries
        *}@endverbatim
        */
        var init = function (s) {
            elLog       =  document.getElementById(s.elId);
            entriesMax  =  s.entries;
            clsNew      =  s.clsNew;
            clsInfo     =  s.clsInfo;
            clsCritical =  s.clsCritical;
            clsFatal    =  s.clsFatal;
            expires     =  s.expires * 1000;
            children    =  0;

            var child   =  elLog.firstChild,
                next;

            while(child) {
                /* Get the next child before removing this one. */
                next = child.nextSibling;

                if(children === entriesMax) {
                    elLog.removeChild(child);

                } else {
                    ++children;
                }
                child   =  next;
            }

            isInit      =  true;
        };

        /**
        * @brief Add a new message to the message board.
        *
        * Every new message entry is applied @c clsNew to it class name. This
        * class is temporary and is removed with the first invocation of log()
        * *after* @c expires seconds have passed. If provided, @p severity
        * specifies a base class that will be added to the entry. This class is
        * permanent and the actual value applied in each case is specified
        * during the initialisation of Logger (see init()).
        *
        * @param[in] msg The message to display. Optional.
        * @param[in] severity String specifying the class of the entry, as
        *   follows:
        *   - "info" applies @c clsInfo
        *   - "critical" applies @c clsCritical
        *   - "fatal" applies @c clsFatal
        */
        var log = function (msg, severity) {
            var entry,
                now     =  new Date(),
                cls     =  "";

            if(severity === "info") {
                cls =  clsInfo;
            } else if(severity === "critical") {
                cls =  clsCritical;
            } else if(severity === "fatal") {
                cls =  clsFatal;
            }

            /* Fallback mode. */
            if(!isInit) {
                alert(msg);
                return;
            }

            entry   =  new ns.LoggerEntry(msg, clsNew + " " + cls, now);
            elLog.insertBefore(entry.elEntry, elLog.firstChild);

            unmarkOld(now);
            entries.push(entry);

            /* Ensure there are not too many entries. */
            if(children === entriesMax) {
                entries.shift();
                elLog.removeChild(elLog.lastChild);
            } else {
                ++children;
            }
        };

        /**
        * @brief Un-mark old entries.
        *
        * All entries that are older than @c expires seconds will have @c clsNew
        * removed from the class name of their element. Note that this only
        * recognises elements add with log().
        *
        * @param[in] now Date object, typically, the current time. If not
        *   specified, a new object will be created internally. Optional.
        */
        var unmarkOld = function (now) {
            var i,
                el;

            now =  now ? now.getTime() : new Date().getTime();
            for(i = entries.length - 1 ; i >= 0 ; --i) {

                if(now - entries[i].stamp.getTime() > expires) {
                    el  =  entries[i].elEntry;

                    /* Stop, on the first non-new entry. */
                    if(entries[i].elEntry.className
                                         .indexOf(clsNew) === -1) break;

                    /* Remove clsNew and, then, trim. */
                    el.className = (" " + el.className + " ")
                                   .replace(clsNew, "")
                                   .replace(/^\s*|\s$/, "");
                }
            }
        };

        /**
        * @brief Remove all entries from the message board.
        *
        * This removes every element within @c elLog.
        */
        var reset = function () {
            entries         =  [];
            elLog.innerHTML =  "";
        };

        return {"init"  : init,
                "log"   : log,
                "reset" : reset};
    })();

    ns.log = ns.Logger.log;

    /**
    * @brief Facilitate validation and access to input fields.
    *
    * A Field is linked to some input elements. It may then be used to validate
    * and return their value displaying an appropriate error message, if
    * necessary, empty them or validate candidate values without actually
    * setting them.
    *
    * This is not a complete definition and may not be instantiated. It should
    * be augmented to provide specific functionality. Any of the provided
    * members should be replaced to that end.
    */
    ns.Field =
    function () {
        throw "Error: Instantiating Field.";
    };
    ns.Field.prototype = {

        /**
        * @brief The id of the underlying input field(s).
        *
        * This is used to gain a reference to the actual input field(s) as well
        * as an indicator of the error message (see _showErrors()).
        */
        id : null,

        /**
        * @brief A reference to the underlying element(s).
        *
        * Field is defined to support a single input element, though it may be
        * augmented to support multiple fields, as well.
        */
        el : null,

        /**
        * @brief Reference to the generated error element.
        */
        elMsg : null,

        /**
        * @brief Class string to apply to the element containing the error.
        *
        * See _showErrors().
        */
        clsError: null,

        /**
        * @brief Set the value of this Field.
        *
        * The value only updates the underlying input fields, if it passes the
        * constrainsts of validate().
        *
        * @param[in] value The value to set to the Field.
        * @returns The value returned by validate().
        */
        set : function(value) {
            value = this.validate(value);
            if(value !== null) {
                this.el.value   =  value;
            }
            return value;
        },

        /**
        * @brief Parse the current value of the Field.
        *
        * To ensure the field remains visually correct when the value is also
        * correct, its contents are updated after parsing.
        *
        * @param[in, out] error Object. Designates that, if validation fails,
        *   an error message should be added to the DOM. This object is added
        *   a new member named after this.id. Its value is an array of error
        *   strings. The generated DOM element (containing the error message)
        *   may be accessed via this.elMsg. Do note that the element is
        *   automatically appended to the DOM (see, _showErrors()). Optional.
        * @returns A valid value parsed form the underlying input fields or @c
        * null.
        */
        get : function(errors) {
            var value   =  this.set(this.el.value);

            if(value === null && typeof errors === "object") {
                errors[this.id] = this._showErrors();
            }

            return value;
        },

        /**
        * @brief Clear the value of the input field(s).
        *
        * @returns this
        */
        reset : function() {
            this.el.value   =  "";
            return this;
        },

        /**
        * @brief Validate the supplied value and return it or return @c null.
        *
        * This function accepts a value to test against the constraints of this
        * Field.
        *
        * @return The validated value, which may not be exactly the same as
        *   @p value (for instance, trimmed of leading and trailing spaces).
        */
        validate : null,

        /**
        * @brief Remove the error message from the DOM.
        *
        * @returns this
        */
        resetMsg : function() {
            if(this.elMsg) {
                this.elMsg.parentNode.removeChild(this.elMsg);
                delete this.elMsg;
            }
            return this;
        },

        /**
        * @brief Class string applied to the generated error elements.
        *
        * @returns this
        */
        setErrorClass : function(clsError) {
            this.clsError   =  clsError;
            return this;
        },

        /**
        * @brief Construct an appropriate error message for this Field.
        *
        * @returns An array of error strings.
        */
        _getErrors : null,

        /**
        * @brief Creates and appends an error element to the DOM.
        *
        * @returns The generated element.
        */
        _showErrors : function() {
            var ul,
                errors = this._getErrors();

            /* Set error message, if validation fails. */
            ul              =  document.createElement("ul");
            ul.innerHTML    =  "<li>"
                            +  errors.join("</li><li>")
                            +  "</li>";

            this.clsError && (ul.className = this.clsError);

            /* Append the message. */
            this.el.parentNode.appendChild(ul);
            this.resetMsg();
            this.elMsg = ul;
            return ul;
        }
    };

    /**
    * @brief Track an integer Field.
    *
    * Since a FieldInt requires a single input field, most of the core
    * functionality remains intact. Only validate() and _getErrors() are
    * implemented.
    *
    * @param[in] idInt id of the input element.
    * @param[in] min The minimum allowable value. The validation and the
    *   generated error message are affected by this value. Optional.
    * @param[in] max The maximum allowable value. The validation and the
    *   generated error message are affected by this value. Optional.
    */
    ns.FieldInt =
    function(idInt, min, max) {
        this.id     =  idInt;
        this.el     =  document.getElementById(idInt);
        this.min    =  min;
        this.max    =  max;
    };
    ns.FieldInt.prototype = {

        /**
        * @brief Parse @p value as an integer within this.min, this.max.
        *
        * If this.min or this.max are @c undefined, they do not affect the
        * validation.
        *
        * @returns A valid integer (within this.min and this.max); @c null, on
        *   error.
        */
        validate : function(value) {
            value   =  parseInt(value, 10);

            if(ns.isNaN(value)
            || (this.min !== undefined && this.min > value)
            || (this.max !== undefined && this.max < value))
                  return null;
            return value;
        },

        /**
        * @brief Constructs an error message for this Field's constraints.
        *
        * `FieldInt' only returns a single string (wrapped in an array) adjusted
        * to the value of this.min and this.max of an instance at the time of
        * its invocation.
        *
        * @returns An array of string errors.
        */
        _getErrors : function() {
            /* Construct the appropriate error message. */
            var msg     =  "";

            /* Construct the tail of the error *without* the period. */
            if(this.min !== undefined && this.max !== undefined) {
                msg = " από " + this.min + " μέχρι " + this.max;

            } else if(this.min !== undefined) {
                msg = " από " + this.min + " και πάνω";

            } else if(this.max !== undefined) {
                msg = " μέχρι " + this.max;
            }

            /* Combine the constant part, the tail (if any) and the period.*/
            msg =  "Απαιτείται ακέραιος" + msg + ".";
            return [msg];
        }
    };
    ns.augment(ns.FieldInt, ns.Field);

    /**
    * @brief Tracks an input field that accepts an IPv4 address.
    *
    * @param[in] id The id attribute of the input field to track.
    */
    ns.FieldIAddr =
    function (id) {
        this.id     =  id;
        this.el     =  document.getElementById(id);
    };
    ns.FieldIAddr.prototype = {

        /**
        * @brief Validate an IP address string.
        *
        * @returns A valid IP address string (as it was specified in @p value)
        *   after removing insignificant zeros and/or leading/trailing white
        *   spaces; @c null, on error.
        */
        validate : function(value) {
            var segments,   // @p value split on dots
                number,     // A single byte of the address
                i;

            value       =  value + "";
            segments    =  value.split(".");
            value       =  "";              // The value is reconstructed
            if(segments.length !== 4) {
                value   =  null;

            } else {
                /* Convert each segment into a number to validate it. */
                for(i = 0 ; i < segments.length ; ++i)  {

                    number = parseInt(segments[i], 10);
                    if(sfIsNaN(number) || number < 0 || number > 255) {
                        value   =  null;
                        break;
                    }
                    /* Join the numbers anew to omit any insignificant zeros. */
                    value  +=  number + ".";
                }
            }

            if(i === 4) {
                value       =  value.substring(0, value.length - 1);
            }

            return value;
        },

        /**
        * @brief Return an array with a single error string.
        *
        * @returns An array of a single string explaining what is a valid IP
        *   address.
        */
        _getErrors : function() {
            return [MSG.error.iaddr4];
        }
    };
    ns.augment(ns.FieldIAddr, ns.Field);

    /**
    * @brief Track a date Field comprised of multiple input fields.
    *
    * Do note, this operates on UTC only (meaning that when setting a date with
    * this.set(), the value for each input element will be extracted via
    * functions such as Date.getUTCFullYear()).
    *
    * To facilitate instantiation, only a single id prefix is required which is
    * assumed to be shared among all input field elements to be tracked by this
    * Field. It is also assumed that, in order to identify each element
    * separately, the following suffixes are:
    *   - -year
    *   - -month
    *   - -date
    *   - -hours
    *   - -minutes
    *   - -seconds
    *
    * The id of this element uses the id of the year (@p idPrefix + "-year").
    *
    * @param[in] idPrefix The common id part of the underlying input fields.
    */
    ns.FieldDateGroup =
    function (idPrefix) {
        this.id         =  idPrefix + "-year";
        this.elYear     =  document.getElementById(idPrefix + "-year");
        this.elMonth    =  document.getElementById(idPrefix + "-month");
        this.elDate     =  document.getElementById(idPrefix + "-date");
        this.elHours    =  document.getElementById(idPrefix + "-hours");
        this.elMinutes  =  document.getElementById(idPrefix + "-minutes");
        this.elSeconds  =  document.getElementById(idPrefix + "-seconds");
        this.el         =  this.elYear;
    };
    ns.FieldDateGroup.prototype = {

        /**
        * @brief Update the Field with the supplied date, provided it is valid.
        *
        * Do note, this sets the underlying fields to the UTC-equivalent of the
        * supplied date.
        *
        * @param[in] blob Either a @c String containing the year or a @c Date
        *   object, in which case, the remaining arguments are ignored.
        * @param[in] month The month (@c 1 through @c 12).
        * @param[in] date The date (day of month). If the value supplied
        *   evaluates to @c 0, it is set to @c 1 to avoid date underflow due to
        *   an empty string.
        * @param[in] hours The hours.
        * @param[in] minutes The minutes.
        * @param[in] seconds The seconds.
        * @returns A Date instance, if a valid date could be constructed from
        *   the arguments; @p null, otherwise.
        */
        set : function(blob, month, date, hours, minutes, seconds) {
            var dt  = this.validate(blob, month, date, hours, minutes, seconds);

            if(dt !== null) {
                /* Make sure numbers are two digits long (except for year). */
                this.elYear.value       =  dt.getUTCFullYear();
                this.elMonth.value      =  sfFixInt(dt.getUTCMonth() + 1,   2);
                this.elDate.value       =  sfFixInt(dt.getUTCDate(),        2);
                this.elHours.value      =  sfFixInt(dt.getUTCHours(),       2);
                this.elMinutes.value    =  sfFixInt(dt.getUTCMinutes(),     2);
                this.elSeconds.value    =  sfFixInt(dt.getUTCSeconds(),     2);
            }
            return dt;
        },

        get : function(errors) {
            var dt = this.set(this.elYear.value,
                              this.elMonth.value,
                              this.elDate.value,
                              this.elHours.value,
                              this.elMinutes.value,
                              this.elSeconds.value);

            if(dt === null && typeof errors === "object") {
                errors[this.id] = this._showErrors();
            }

            return dt;
        },

        reset : function() {
            this.elYear.value       =  "";
            this.elMonth.value      =  "";
            this.elDate.value       =  "";
            this.elHours.value      =  "";
            this.elMinutes.value    =  "";
            this.elSeconds.value    =  "";
            return this;
        },

        /**
        * @brief Validate the arguments as if there were a date.
        *
        * @param[in] blob Either a @c String containing the year or a @c Date
        *   object, in which case, the remaining arguments are ignored.
        * @param[in] month The month (@c 1 through @c 12).
        * @param[in] date The date (day of month). If the value supplied
        *   evaluates to @c 0, it is set to @c 1 to avoid date underflow due to
        *   an empty string.
        * @param[in] hours The hours.
        * @param[in] minutes The minutes.
        * @param[in] seconds The seconds.
        * @returns A Date instance, if a valid date could be constructed from
        *   the arguments; @p null, otherwise.
        */
        validate : function(blob, month, date, hours, minutes, seconds) {
            var dt;         // The parsed date

            if(typeof blob === "string") {

                /* Month is zero-based. */
                if(!sfIsNaN(month) && month > 0) --month;

                /* Avoid date underflow to previous month. */
                if(date == 0) date = 1;

                /* The device operates in UTC. Assume the values inserted are in
                * UTC as well. */
                dt  =  new Date(Date.UTC(blob,
                                         month,
                                         date,
                                         hours,
                                         minutes,
                                         seconds));

            } else {
                dt  =  blob;
            }

            /* Check validity of date. For instance, if non-digits where
            * supplied, that would have caused an invalid date (NaN). */
            if(sfIsNaN(dt.getTime())) return null;
            return dt;
        },

        /**
        * @brief Return an array with a single error string.
        *
        * @returns An array of a single string explaining that the date is
        *   invalid.
        */
        _getErrors : function() {
            return ["Μη έγκυρη ημερομηνία/ώρα."];
        }
    };
    ns.augment(ns.FieldDateGroup, ns.Field);

    /**
    * @brief Validate coordinate fields.
    *
    * Field values are updated to match the one parsed.
    *
    * This actually envelopes three FieldInt members which may be accessed at
    * any time to alter their behaviour. For instance, to set the minimum and
    * maximum allowable values, this.fieldX, this.fieldY and this.fieldZ may be
    * used (provided they have been initialised; see parameters). Defaults are
    * @c 0 and @c 255, respectively. To cancel the effects of a limit to any of
    * the aforementioned Field members, its respective @c min and/or @c max
    * should become undefined (with @c delete or be set to @c undefined).
    *
    * At least one field id should be specified (but if only one is required, it
    * would be more efficient to simply use `FieldInt' directly). this.id will
    * be set to any one valid supplied arguments, with an order of preference:
    * idX, idY, idZ.
    *
    * When validating, only if each initialised Field validates separately, will
    * this Field succeed as well, in which case, an object with member 
    *
    * @param[in] idX The id attribute of the field containing the X-coordinate.
    *   Supplying this will initialise this.fieldX. Optional.
    * @param[in] idY The id attribute of the field containing the Y-coordinate.
    *   Supplying this will initialise this.fieldY. Optional.
    * @param[in] idZ The id attribute of the field containing the Z-coordinate.
    *   Supplying this will initialise this.fieldZ. Optional.
    */
    ns.FieldPoint =
    function (idX, idY, idZ) {
        var id;

        /* Initialise a field for each defined argument. */
        idZ && (this.fieldZ = new ns.FieldInt(idZ, 0, 255)) && (this.id = idZ);
        idY && (this.fieldY = new ns.FieldInt(idY, 0, 255)) && (this.id = idY);
        idX && (this.fieldX = new ns.FieldInt(idX, 0, 255)) && (this.id = idX);

        if(this.id === idX)         this.el = this.fieldX.el;
        else if(this.id === idY)    this.el = this.fieldY.el;
        else if(this.id === idZ)    this.el = this.fieldZ.el;

    };
    ns.FieldPoint.prototype = {

        /**
        * @brief 
        *
        * Because not all three coordinates may have been initialised, it is up
        * to the caller to provide values for those that have been. The others
        * are always ignored. In order for this.set() to succeed, all the
        * initialised Fields must pass validation.
        *
        * @param[in] x Value for this.fieldX.
        * @param[in] y Value for this.fieldY.
        * @param[in] z Value for this.fieldZ.
        * @returns An object with three members at most (@c x, @c y and @c z),
        *   each set to the corresponding argument value, if the initialised
        *   Fields pass validation; @c null, otherwise.
        */
        set : function(x, y, z) {
            var point   =  this.validate(x, y, z);

            if(point !== null) {
                /* Since validation succeeded on all of them as a whole, no need
                * to validate each separately, so by-pass .validate(). */
                this.fieldX && (this.fieldX.el.value = point.x);
                this.fieldY && (this.fieldY.el.value = point.y);
                this.fieldZ && (this.fieldZ.el.value = point.z);
            }
            return point;
        },

        /**
        * @brief Retrieve and validate Field contents.
        *
        * It return @c null, if any of the initialised Fields fails validation.
        * On the contrary, if all initialised Fields succeed, a single object
        * containing a member-value pair for each initialised Field *only*, is
        * returned. If it is required to determine the Field(s) that failed
        * validation, three status members are available: this.isValidX,
        * this.isValidY, this.isValidZ.
        *
        * @param[out] error Contains error strings. If any errors occurred
        *   during parsing, they will be inserted into `error[id]' as an array
        *   of strings, where @c id is the first non-empty constructor-supplied
        *   value. A single error string is produced for each coordinate similar
        *   to the one generated by FieldInt._getError, but adjusted to include
        *   the name of that coordinate.
        */
        get : function(errors) {
            /* Fetch the values directly from the input fields so that they may
            * be validated as a group via this.validate(). */
            var x       =  this.fieldX ? this.fieldX.el.value : null,
                y       =  this.fieldY ? this.fieldY.el.value : null,
                z       =  this.fieldZ ? this.fieldZ.el.value : null,
                point   =  this.set(x, y, z);

            if(point === null && typeof errors === "object") {
                errors[this.id] = this._showErrors();
            }

            return point;
        },

        reset : function() {
            this.fieldX && (this.fieldX.el.value  =  "");
            this.fieldY && (this.fieldY.el.value  =  "");
            this.fieldZ && (this.fieldZ.el.value  =  "");
        },

        /**
        * @brief Validate the supplied values.
        *
        * Each supplied value is validated according to the constraints of the
        * appropriate initialised Field.
        *
        * @returns An object with a member for each initialised Field and the
        *   corresponding argument value, if the supplied values pass
        *   validation; @c null, otherwise.
        */
        validate : function(x, y, z) {
            var point   =  {},          // Contains the parsed values
                value   =  point;       // It may be altered to @c null

            /* Assume the values are correct. */
            this.isValidX = this.isValidY = this.isValidZ = true;

            /* Use .validate() on each initialised Field. @c point is added a
            * member for each such Field and is given the return value of
            * .validate() even if it is @c null, in which case @c value is set
            * to @c null and  the corresponding this.isValid[X|Y|Z] is set to @c
            * false. */
            this.fieldX && ((point.x = this.fieldX.validate(x)) === null)
                        && ((this.isValidX = false) || (value = null));
            this.fieldY && ((point.y = this.fieldY.validate(y)) === null)
                        && ((this.isValidY = false) || (value = null));
            this.fieldZ && ((point.z = this.fieldZ.validate(z)) === null)
                        && ((this.isValidZ = false) || (value = null));

            /* If there has been at least one error, @c value will no longer be
            * a reference to @c point */
            return value;
        },

        _getErrors : function() {
            var errors  =   [],
                str;

            if(this.isValidX === false) {
                str =  this.fieldX._getErrors()[0];
                str =  "Για το X α" + str.substring(1);
                errors.push(str);
            }
            if(this.isValidY === false) {
                str =  this.fieldY._getErrors()[0];
                str =  "Για το Y α" + str.substring(1);
                errors.push(str);
            }
            if(this.isValidZ === false) {
                str =  this.fieldZ._getErrors()[0];
                str =  "Για το Z α" + str.substring(1);
                errors.push(str);
            }

            return errors;
        }
    };
    ns.augment(ns.FieldPoint, ns.Field);

}(window.gNS = window.gNS || {}));
