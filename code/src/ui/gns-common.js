;(function(ns) {

    /**
    * @brief Allows to select one among a collection of peers.
    *
    * Calling switchTo() with a key found in @p arrKeys, results in applying
    * class @p clsActive to the element @p arrEls in the corresponding index.
    * Any previously selected element is automatically applied @p clsInactive.
    * At most one element may be selected at a time.
    *
    * @param[in] arrKeys Strings to identify each element in @arrEls (on a
    *   one-on-one basis).
    * @param[in] arrEls Elements to be applied classes @p clsActive and @p
    *   clsInactive.
    * @param[in] clsActive
    * @param[in] clsInactive
    * @param[in] keyDefault Key of the element to select upon instantiation.
    * Optional.
    */
    ns.OneOfMany =
    function (arrKeys, arrEls, clsActive, clsInactive, keyDefault) {
        this.one        =  null;
        this.many       =  {};
        this.active     =  clsActive;
        this.inactive   =  clsInactive;

        var i,              // Index of @p arrKeys-arrEls pair
            el;             // An element from @p arrEls

        for(i = 0 ; i < arrKeys.length ; ++i) {
            el                      =  arrEls[i];
            el.className            =  clsInactive;
            this.many[arrKeys[i]]   =  el;
        }

        if(keyDefault !== undefined) {
            this.switchTo(keyDefault);
        }
    };
    ns.OneOfMany.prototype = {

        /**
        * @brief Selects the element that is paired with @p key.
        *
        * The current element (if any) is set to this.inactive regardless of
        * whether @p key corresponds to an available key.
        *
        * @param[in] key The key for the element to select. If @c null, none
        *   will be selected.
        */
        switchTo : function(key) {
            if(this.one !== null) {
                this.one.className  =  this.inactive;
                this.one            =  null;
            }

            if(this.many[key]) {
                this.one            =  this.many[key];
                this.one.className  =  this.active;
            }
        }
    };

    /**
    * @brief Facilitates manaing pagination controls.
    *
    * Every instance keeps track of an element that displays the number results
    * and a second element for page anchors (pagination). Upon invoking show(),
    * the `innerHTML' of those elements is updated accordingly.
    *
    * The link (`href') of each page anchor is generated by an external
    * function,@p fnLinker. @p clsCurrent is a class string to apply to the page
    * anchor dubbed as current (or selected), while @p clsOther is applied to
    * every other.
    *
    * @param[in] elTotal Element which innerHTML will be set to the amount of
    *   search results.
    * @param[in] elPages Element which innerHTML will be populated with a number
    *   of anchors.
    * @param[in] clsCurrent The currently displayed anchor page will be applied
    *   this class.
    * @param[in] clsOther All anchors, except for the selected one, will be
    *   applied this class.
    * @param[in] fnLinker A function that accepts a page number/index (starting
    *   at @c 1) and returns an appropriate value for its corresponding anchor's
    *   `href' attribute.
    */
    ns.Paginator =
    function (elTotal, elPages, clsCurrent, clsOther, fnLinker) {
        this.elTotal    =  elTotal;
        this.elPages    =  elPages;
        this.clsCurrent =  clsCurrent;
        this.clsOther   =  clsOther;
        this.linker     =  fnLinker;
    };
    ns.Paginator.prototype = {

        /**
        * @brief Update the pagination display.
        *
        * @param[in] results The amount of total results.
        * @param[in] anchors The amount of page links to generate.
        * @param[in] current The index of the currently displayed page (starts
        *   at @c 1). This page will not have its `href' set, whereas its class
        *   will be set to clsCurrent unlike the other anchors that acquire
        *   clsOther.
        */
        show : function(results, anchors, current) {
            var i,
                limit,
                pages   =  "";

            this.elTotal.innerHTML  =  results;
            this.elPages.innerHTML  =  "";

            i       =  1;
            limit   =  current;

            while(i <= anchors) {
                for(i ; i < limit ; ++i) {
                    pages  +=  "<a class=\"" + this.clsOther  + "\" "
                           +      "href=\""  + this.linker(i) + "\">"
                           +   i + "</a>";
                }

                if(i === current) {
                    /* Set the class of the current anchor but do not provide
                    * a link. */
                    pages  +=  "<a class=\"" + this.clsCurrent + "\">"
                           +   i + "</a>";
                    ++i;
                    limit   =  anchors + 1;
                }
            }

            if(pages === "") pages +=  " 0";
            this.elPages.innerHTML  =  pages;
        },

        /**
        * @brief Set totals @c 0 and page anchors to a single &ndash;.
        */
        reset : function() {
            this.elTotal.value      =  0;
            this.elPages.innerHTML  =  "&ndash;";
        }
    };

    /**
    * @brief Expand @p child's prototype with @p parent's
    *
    * Prototype members than exist on both @p child and @p parent are ignored,
    * by default, unless @p override evaluates to @c true.
    *
    * @param[in,out] child Contains the prototype to be expanded.
    * @param[in,out] parent Contains the prototype to be copied.
    * @param[in] override Replace common prototype members with those of @p
    *   parent.
    */
    ns.augment = ns.augment ||
    function (child, parent, override) {
        var i;

        for(i in parent.prototype) {
            if(child.prototype[i] !== undefined && !override) continue;
            child.prototype[i] = parent.prototype[i];
        }
    }

    /**
    * @brief Register a callback function for a particular element.
    *
    * Currently, a single callback is supported in fallback mode.
    *
    * @param[in] el The element to be attached a listener.
    * @param[in] event String of the event name (non-inclusive of "on").
    * @param[in] fn The callback function / event handler.
    */
    ns.addEventListener = ns.addEventListener ||
    function (el, event, fn) {
        if(el.addEventListener) {
            el.addEventListener(event, fn);

        /* This should suffice for IE versions prior to 9. */
        } else if(el.attachEvent) {
            el.attachEvent("on" + event, fn);

        } else {
            el["on" + event] = fn;
        }
    };

    /**
    * @brief Return an object that can be used to make HTTP request objects.
    *
    * If instantiation of XMLHttpRequest is not possible, Msxml2.XMLHTTP and
    * Microsoft.XMLHTTP will be attempted in that order. If none of these
    * works, @c null is returned.
    *
    * @returns An XML HTTP object or @c null.
    */
    ns.createRequest = ns.createRequest ||
    function () {
        var request = null;

        if(window.XMLHttpRequest) {
          request       =  new XMLHttpRequest();

        } else if(window.ActiveXObject) {
          try {
            request     =  new ActiveXObject("Msxml2.XMLHTTP");

          } catch(e) {
            try {
              request   =  new ActiveXObject("Microsoft.XMLHTTP");

            } catch(e) {
            }
          }
        }
        return request;
    };

    /**
    * @brief Check whether @p value is NaN.
    *
    * This deals with the issue of isNaN() returning @c false even for
    * non-number values.
    *
    * @param[in] value The value to check.
    * @returns @c true if @p value is NaN; @p false, otherwise.
    */
    ns.isNaN = ns.isNaN ||
    function (value) {
        if(typeof value !== 'number') return false;
        return isNaN(value);
    };

    /**
    * @brief Check whether @p collection is empty.
    *
    * @param[in] collection The collection to check.
    * @returns @c true if @p collection is empty or @c null; @p false,
    *   otherwise.
    */
    ns.isEmpty = ns.isEmpty ||
    function (collection) {
        var i   =  0,
            val;

        for(val in collection) {
            ++i;
            break;
        }
        return i === 0;
    };

    /**
    * @brief Convert a number into a string of fixed digits.
    *
    * @param[in] num The number to prefix with zeros.
    * @param[in] digits The number of total digits to produce.
    * @returns A string number with that many @p digits.
    */
    ns.fixInt = ns.fixInt ||
    function (num, digits) {
        var value   =  num.toString(10),
            times   =  digits - value.length,
            i;

        for(i = 0 ; i < times ; ++i) {
            value = "0" + value;
        }
        return value;
    };

}(window.gNS = window.gNS || {}));
